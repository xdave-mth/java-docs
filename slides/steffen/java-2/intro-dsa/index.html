<!doctype html>
<html lang="de" dir="ltr" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.2.0">
<title data-rh="true">Programmieren mit Java</title><meta data-rh="true" property="og:title" content="Programmieren mit Java"><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://jappuccini.github.io/java-docs/slides/steffen/java-2/intro-dsa"><meta data-rh="true" property="og:locale" content="de"><meta data-rh="true" name="docusaurus_locale" content="de"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="de"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><link data-rh="true" rel="icon" href="/java-docs/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/intro-dsa"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/intro-dsa" hreflang="de"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/intro-dsa" hreflang="x-default"><link rel="stylesheet" href="/java-docs/assets/css/styles.d55280a3.css">
<script src="/java-docs/assets/js/runtime~main.17bd1032.js" defer="defer"></script>
<script src="/java-docs/assets/js/main.421f1631.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div class="reveal reveal-viewport" style="width:100vw;height:100vh"><div class="slides"><section><section><h2>Agenda</h2><ul><li class="fragment">Intro</li><li class="fragment">Problemfelder</li><li class="fragment">Erwartungen an DSA</li><li class="fragment">Landau-Notation</li><li class="fragment">Fallbeispiel Problem</li></ul></section></section><section><section><h2>Intro</h2></section><section><h2>Was ist ein Algorithmus?</h2><p class="fragment">systematische Vorgehensweise zur Lösung eines Problems</p></section><section><h2>Charakteristika</h2><ul><li tabindex="0" data-tooltip="Das Verfahren muss in einem endlichen Text eindeutig beschreibbar sein.">Finitheit</li><li tabindex="0" data-tooltip="Jeder Schritt des Verfahrens muss tatsächlich ausführbar sein.">Ausführbarkeit</li><li tabindex="0" data-tooltip="Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz benötigen. (Space Complexity)">Dynamische Finitheit</li><li tabindex="0" data-tooltip="Das Verfahren darf nur endlich viele Schritte benötigen. (Time Complexity)">Terminierung</li><li tabindex="0" data-tooltip="Der Algorithmus muss bei denselben Voraussetzungen das gleiche Ergebnis liefern.">Determiniertheit</li><li tabindex="0" data-tooltip="Die nächste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt eindeutig definiert.">Determinismus</li></ul></section><section><h2>Was ist eine Datenstruktur?</h2><p class="fragment">spezifische Anordung von Daten zur effizienten Verwaltung eines Problems</p></section><section><h2>Charakteristika</h2><ul><li tabindex="0" data-tooltip="Die Größe wird zu Beginn einmalig festgelegt.">statisch</li><li tabindex="0" data-tooltip="Die Größe ist veränderbar.">dynamisch</li></ul></section><section><h2>Kann man Datenstrukturen und Algorithmen trennen?</h2><p class="fragment">Nein nur die Kombination bringt etwas.</p><p class="fragment">Was bringt ein Array ohne (über)schreiben und lesen?</p><p class="fragment">Was bringt eine for-Schleife ohne Array?</p></section><section><h2>Unsere Definition von DSA</h2><p class="fragment">Ein Algorithmus (A) erzeugt, manipuliert und entfernt eine oder mehrere Datenstrukturen(DS) um ein spezifisches Problem effizient zu lösen.</p></section></section><section><section><h2>Problemfelder</h2></section><section><h2>Prozessprobleme</h2><ul><li class="fragment">Suche</li><li class="fragment">Sortierung</li><li class="fragment">Verarbeitung</li></ul></section><section><h2>Technische Probleme</h2><ul><li class="fragment">Zeitkomplexität</li><li class="fragment">Speicherkomplexität</li></ul></section><section><h2>Optimum</h2><p class="fragment">Das Optimum kann nur für ein Problemfeld für ein technisches Problem gefunden werden.</p><p class="fragment">Es existiert kein Allgemeiner Algorithmus, der jedes Problem in der kürzesten Zeit mit der geringsten Speichermenge löst.</p></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/intro" target="_blank" rel="noopener noreferrer">Demo - Performance von Suche und Verarbeitung</a></h2><ul><li class="fragment">Erstellen einer HashMap &amp; ArrayList</li><li class="fragment">Suchen in einer HashMap &amp; ArrayList</li><li class="fragment">Löschen in einer HashMap &amp; ArrayList</li></ul></section></section><section><section><h2>Erwartungen an DSA</h2></section><section><h2>Inhalte</h2><ul><li class="fragment">Grundlegende Praktikable Datenstrukturen</li><li class="fragment">Worst Case Szenario</li><li class="fragment">keine Beweise</li><li data-tooltip="IMHO!" tabindex="0" class="fragment">kaum Coding (von euch, da Projektbericht)</li><li class="fragment">Einstieg in das Themengebiet</li></ul></section></section><section><section><h2>Landaunotation</h2><p class="foot-note">wird auch Big-O Notation genannt</p></section><section><h2>Landaunotation (Big-O)</h2><p class="fragment">wird verwendet um Algorithmen in Bezug auf Speicher- und Zeitanforderungen zu kategorisieren.</p><p class="fragment">ist keine exakte Messung, sondern soll das Wachstum des Algorithmus generalisieren.</p></section><section><h2>Warum brauchen Big-O?</h2><p>Wenn wir wissen, welche Stärken und Schwächen ein Algorithmus hat, können wie den besten Algorithmus für unser Problem nutzen.</p><p class="foot-note">Ich benutz immer Big-O zum erklären</p></section><section><h2>Was ist Big-O?</h2><p>gibt an in welchem Verhältnis ein Algorithmus abhängig vom<!-- --> <b>input</b> in Bezug auf Laufzeit und Speicher wächst</p></section><section><h2>Beispiel für Big-O</h2><p>O(N)</p><ul><li class="fragment">10 Elemente entspricht 10 Zeiteinheiten</li><li class="fragment">20 Elemente entspricht 20 Zeiteinheiten</li></ul></section><section><h2>Beispiel für Big-O</h2><pre><code class="java">public class BigO {
  // O(N)
  public static void method(int[] n) {
    int sum = 0;
    for(int i = 0; i &gt; n.length; i++) {
      sum += n[i];
    }
    return sum;
  }
}
</code></pre><p class="fragment">Jahresgehalt eines Mitarbeiters</p></section><section data-background-size="contain" data-background-image="/java-docs/assets/images/big-o-complexity-4503eb9ed207279ffce06d4edeebcd51.png"></section><section><h2>Beispiel für Big-O</h2><pre><code class="java">public class BigO {
  // O(N^2)
  public static void method(int[] n) {
    int sum = 0;
    for(int i = 0; i &gt; n.length; i++) {
      for(int j = 0; j &gt; n.length; j++) {
        sum += n[j];
      }
    }
    return sum;
  }
}
</code></pre><p class="fragment">Jahresgehalt jedes Mitarbeiters einer Abteilung</p></section><section><h2>Beispiel für Big-O</h2><pre><code class="java">public class BigO {
  // O(N^3)
  public static void method(int[] n) {
    int sum = 0;
    for(int i = 0; i &gt; n.length; i++) {
      for(int j = 0; j &gt; n.length; j++) {
        for(int k = 0; k &gt; n.length; k++) {
          sum += n[k];
        }
      }
    }
    return sum;
  }
}
</code></pre><p class="fragment">Jahresgehalt jedes Mitarbeiters jeder Abteilung</p></section><section><h2>Big-O von diesem Code?</h2><pre><code class="java">public class BigO {
  public static void method(int[] n) {
    int sum = 0;
    for(int i = 0; i &gt; n.length; i++) {
      sum += n[i];
    }
    for(int i = 0; i &gt; n.length; i++) {
      sum += n[i];
    }
    return sum;
  }
}
</code></pre><p class="fragment">praktisch: O(2N) → O(N)</p></section><section><h2>Warum O(N) anstatt O(2N)</h2><table><th>N</th><th>O(10N)</th><th>O(N^2)</th><tr class="fragment"><td>1</td><td>10</td><td>1</td></tr><tr class="fragment"><td>5</td><td>50</td><td>25</td></tr><tr class="fragment"><td>100</td><td>1000</td><td>10.000</td></tr><tr class="fragment"><td>1000</td><td>10.000</td><td>1.000.000</td></tr><tr class="fragment"><td>10.000</td><td>100.000</td><td>100.000.000</td></tr></table><p class="fragment">Konstanten können ignoriert werden.</p></section><section><h2>Big-O von diesem Code?</h2><pre><code class="java">public class BigO {
  public static void method(int[] n) {
    int sum = 0;
    for(int i = 0; i &gt; n.length; i++) {
      if(sum > 9876) {
        return sum;
      }
      sum += n[i];
    }
    return sum;
  }
}
</code></pre><p class="fragment">O(N) → Worst-Case-Szenario</p></section><section><h2>Unsere Regeln</h2><ul><li>Wachstum ist abhängig vom Input</li><li>Konstanten werden ignoriert</li><li>Worst-Case ist unser default</li></ul></section></section><section><h2>Fallbeispiel Problem</h2></section></div></div></div>
</body>
</html>