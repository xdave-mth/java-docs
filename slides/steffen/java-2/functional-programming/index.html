<!doctype html>
<html lang="de" dir="ltr" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.2.1">
<title data-rh="true">Programmieren mit Java</title><meta data-rh="true" property="og:title" content="Programmieren mit Java"><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://jappuccini.github.io/java-docs/slides/steffen/java-2/functional-programming"><meta data-rh="true" property="og:locale" content="de"><meta data-rh="true" name="docusaurus_locale" content="de"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="de"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><link data-rh="true" rel="icon" href="/java-docs/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/functional-programming"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/functional-programming" hreflang="de"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/functional-programming" hreflang="x-default"><link rel="stylesheet" href="/java-docs/assets/css/styles.482a3224.css">
<script src="/java-docs/assets/js/runtime~main.0fd8afb5.js" defer="defer"></script>
<script src="/java-docs/assets/js/main.3e5ad7cd.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div class="reveal reveal-viewport" style="width:100vw;height:100vh"><div class="slides"><section><section><h2>Agenda</h2><ul><li class="fragment">Funktionale Programmierung</li><li class="fragment">Lambdafunktionen</li><li class="fragment">Allgemeine Funktionale Interfaces</li><li class="fragment">Methodenreferenzen</li></ul></section></section><section><section><h2>Funktionale Programmierung</h2></section><section><p>Funktionale Programmierung ist ein <b>Programmierparadigma</b>, bei dem Funktionen als Werte behandelt werden und auf Seiteneffekte verzichtet wird.</p></section><section><h2>Funktionen als Werte</h2>Funktionen...<ul><li class="fragment">sind Methoden</li><li class="fragment">können als Parameter definiert werden</li><li class="fragment">können als Argument definiert werden</li><li class="fragment">können als Variable definiert werden</li></ul></section><section><h2>Seiteneffekt</h2><p class="fragment">Ein Seiteneffekt beschreibt eine Zustandsänderung</p></section><section><h2>Beispiele Seiteneffekte</h2><pre class="fragment"><code data-line-numbers="true" class="java">public class Human {
  private int age;
  
  public void setAge(age) {
    this.age = age;
    /*Seiteneffekt, da Wert außerhalb
     der Funktion verändert wird */ 
  }
  public int getAge() {
    return age;
    /*Kein Seiteneffekt, da Wert nicht außerhalb
     der Funktion verändert wird */ 
  }
}
</code></pre></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/functionalprogramming" target="_blank" rel="noopener noreferrer">Demo - Lambda Funktionen</a></h2><ul><li class="fragment">Age Comparator</li><li class="fragment"><a href="/java-docs/documentation/inner-classes">Anonyme Klasse*</a></li><li class="fragment">Anonyme Funktion</li></ul><p style="font-size:8px;position:absolute;bottom:0;right:0">*NKR</p></section></section><section><section><h2>Lambdafunktionen</h2></section><section><h2>Lambdafunktion</h2><p class="fragment">Eine Lambdafunktion ist eine Methode ohne Name, die wie eine Referenzvariable verwendet werden kann.</p><pre class="fragment"><code data-line-numbers="4" class="java">public class Main {
  public static void main(String[] args) {
    Comparator&lt;Human&gt; sortAge;
    sortAge = (h1, h2) -> h1.age() > h2.age() ? 1 : -1;
  }
}
</code></pre><span class="fragment foot-note">Lambdafunktionen werden auch anonyme Funktion, anonymous function oder arrow function genannt.</span></section><section><h2>Typisierung</h2><p class="fragment">Ein funkionales Interface wird für die Typisierung einer Lambdafunktion verwendet.</p><pre class="fragment"><code data-line-numbers="3" class="java">public class Main {
  public static void main(String[] args) {
    Comparator&lt;Human&gt; sortAge;
    sortAge = (h1, h2) -> h1.age() > h2.age() ? 1 : -1;
  }
}
</code></pre><p class="fragment foot-note">Ein funktionales Interface ist ein Interface mit genau einer abstrakten Methode und einer speziellen Annotation.</p></section><section><h2>Funktionales Interface</h2><p class="fragment">Funktionale Interfaces werden mit @FunctionalInterface markiert, z.B.<!-- --> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Comparator.html" target="_blank" rel="noopener noreferrer">Comparator</a></p><pre class="fragment"><code class="java">@FunctionalInterface
public interface Comparator&lt;T&gt; {
  public int compare(T o1, T o2);
}
</code></pre><p class="fragment foot-note">Nicht jedes Interface mit einer einzigen abstrakten Methode ist funktional, z.B.<!-- --> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html" target="_blank" rel="noopener noreferrer">Comparable</a></p></section><section><h2>Syntax Lambdafunktion</h2><ul><li class="fragment">Kein Parameter</li><li class="fragment">Ein Parameter</li><li class="fragment">Mehrere Parameter</li><li class="fragment">Eine Anweisung</li><li class="fragment">Mehrere Anweisungen</li><li class="fragment">Return Anweisung</li></ul></section><section><h2>Kein Parameter</h2><p class="fragment">Hat das funktionale Interface keinen Parameter, werden runde Klammern benötigt.</p><pre class="fragment"><code class="java">public interface NoParamFunction {
 public void do();
};
</code></pre><pre class="fragment"><code class="java">NoParamFunction function = () -&gt; {
  System.out.println("Kein Parameter");
};
</code></pre></section><section><h2>Ein Parameter</h2><p class="fragment">Hat das funktionale Interface einen Parameter, werden keine runden Klammern benötigt.</p><pre class="fragment"><code class="java">public interface OneParamFunction {
 public void do(String one);
}
</code></pre><pre class="fragment"><code class="java">OneParamFunction function = one -&gt; {
  System.out.println("Ein Parameter: " + one);
};
</code></pre></section><section><h2>Mehrere Parameter</h2><p class="fragment">Hat das funktionale Interface mehrere Parameter, werden runden Klammern benötigt.</p><pre class="fragment"><code class="java">public interface MultiParamFunction {
 public void do(String one, String two);
}
</code></pre><pre class="fragment"><code class="java">MultiParamFunction function = (one, two) -&gt; {
  System.out.println("Zwei Parameter: " + one + two);
};
</code></pre></section><section><h2>Eine Anweisung</h2><p class="fragment">Besteht die Lambdafunktion aus einer Anweisung sind keine geschweifte Klammern notwendig.</p><pre class="fragment"><code class="java">MultiParamFunction function = (one, two) -&gt; 
  System.out.println("Zwei Parameter: " + one + two);
</code></pre></section><section><h2>Mehrere Anweisungen</h2><p class="fragment">Besteht die Lambdafunktion aus mehrern Anweisungen sind geschweifte Klammern notwendig.</p><pre class="fragment"><code class="java">MultiParamFunction function = (one, two) -&gt; {
  System.out.println("Parameter Eins: " + one);
  System.out.println("Parameter Zwei: " + two);
};
</code></pre></section><section><h2>return-Anweisung</h2><p class="fragment">Besteht die Lambdafunktion aus einer einzelnen return Anweisung, sind keine geschweifte Klammern notwendig und das return Statement kann weggelassen werden.</p><pre class="fragment"><code class="java">public interface OneParamReturnFunction {
 public boolean validate(Human human);
}
</code></pre><pre class="fragment"><code class="java">OneParamReturnFunction function = h -&gt; h.age() > 10
</code></pre></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/functionalinterfaces/owninterfaces" target="_blank" rel="noopener noreferrer">Demo - Eigene Funktionale Interfaces</a></h2><ul><li class="fragment">Intro Shopping List Example</li><li class="fragment">Problem 1</li><li class="fragment">Problem 2</li></ul></section></section><section><section><h2>Allgemeine Funktionale Interfaces</h2></section><section><h2>Grundkategorien von Funktionalen Interfaces</h2><ul><li class="fragment">Consumer</li><li class="fragment">Function</li><li class="fragment">Predicate</li><li class="fragment">Supplier</li></ul></section><section><h2>Consumer</h2><pre class="fragment"><code class="java">public interface Consumer&lt;T&gt; {
  public void accept(T t);
}
</code></pre><pre class="fragment"><code class="java">public interface BiConsumer&lt;T, U&gt; {
  public void accept(T t, U u);
}
</code></pre><p class="fragment">Code ausführen ohne Daten weiterzugeben.</p></section><section><h2>Function</h2><pre class="fragment"><code class="java">public interface Function&lt;T, R&gt; {
  public R apply(T t);
}
</code></pre><pre class="fragment"><code class="java">public interface BiFunction&lt;T, U, R&gt; {
  public R apply(T t, U u);
}
</code></pre><pre class="fragment"><code class="java">public interface UnaryOperator&lt;T&gt; {
  public T apply(T t);
}
</code></pre><pre class="fragment"><code class="java">public interface BinaryOperator&lt;T&gt; {
  public T apply(T t1, T t2);
}
</code></pre><p class="fragment">Code ausführen, der Daten zurückgibt.</p></section><section><h2>Predicate</h2><pre class="fragment"><code class="java">public interface Predicate&lt;T&gt; {
  public boolean test(T t);
}
</code></pre><p class="fragment">Code ausführen, der true oder false zurückgibt.</p></section><section><h2>Supplier*</h2><pre class="fragment"><code class="java">public interface Supplier&lt;T&gt; {
  public T get();
}
</code></pre><p class="fragment">Code ausführen, der Daten vom Typ T zurückgibt.</p><div class="fragment"><p style="font-size:8px;position:absolute;bottom:0;right:0">*NKR</p></div></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/functionalinterfaces/knowninterfaces" target="_blank" rel="noopener noreferrer">Demo - Allgemeine Funktionale Interfaces</a></h2><ul><li class="fragment">Consumer anstatt ProductsChangedConsumer</li><li class="fragment">Predicate anstatt AddAllowedChecker</li></ul></section></section><section><section><h2>Methodenreferenzen</h2></section><section><h2>Warum Methodenreferenzen?</h2><p class="fragment">Mit Methodenreferenzen kann man noch weniger Code schreiben.</p><p class="fragment">Hat ein Parameter die gleiche Signatur, wie eine Methode, kann diese Methode als Methodenreferenz übergeben werden.</p></section><section><h2>Beispiel ArrayList -<!-- --> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ArrayList.html#forEach(java.util.function.Consumer)" target="_blank" rel="noopener noreferrer">For Each</a></h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;()
    
    // lambda funktion
    names.forEach((name) -&gt System.out.println(name));
    
    // methodenreferenz
    names.forEach(System.out::println);
 }
}
</code></pre></section><section><h2>Verwenden von Methodenreferenzen?</h2><p class="fragment">Anstatt die Methode über einen Punkt aufzurufen, wird ein zweifacher Doppelpunkt verwendet.</p><p class="fragment">Mit dem &quot;new&quot; nach dem zweifachen Doppelpunkt kann auch der Konstruktor einer Klasse referenziert werden.</p><p style="font-size:8px;position:absolute;bottom:0;right:0">*NKR</p></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/functionalinterfaces/methodreferences" target="_blank" rel="noopener noreferrer">Demo - Methodenreferenzen</a></h2><ul><li class="fragment">Methodensignatur System.out.println</li><li class="fragment">OneTimePrinter</li></ul></section></section><section><h2>Rest of the Day</h2><ul><li class="fragment"><a href="https://jappuccini.github.io/java-docs/exercises/lambdas/" target="_blank" rel="noopener noreferrer">Lambdas</a></li></ul><p class="fragment font-medium">Bei Lambdas 01 kann die Teilaufgabe mit anonymer Klasse ignoriert werden.</p></section></div></div></div>
</body>
</html>