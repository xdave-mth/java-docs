<!doctype html>
<html lang="de" dir="ltr" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.2.1">
<title data-rh="true">Programmieren mit Java</title><meta data-rh="true" property="og:title" content="Programmieren mit Java"><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://jappuccini.github.io/java-docs/slides/steffen/java-2/sort-algo"><meta data-rh="true" property="og:locale" content="de"><meta data-rh="true" name="docusaurus_locale" content="de"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="de"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><link data-rh="true" rel="icon" href="/java-docs/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/sort-algo"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/sort-algo" hreflang="de"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/java-2/sort-algo" hreflang="x-default"><link rel="stylesheet" href="/java-docs/assets/css/styles.482a3224.css">
<script src="/java-docs/assets/js/runtime~main.bebb3746.js" defer="defer"></script>
<script src="/java-docs/assets/js/main.3e5ad7cd.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div class="reveal reveal-viewport" style="width:100vw;height:100vh"><div class="slides"><section><section><h2>Sortieralgorithmen</h2></section><section><h2>Agenda</h2><ul><li class="fragment">Intro</li><li class="fragment">Selection Sort</li><li class="fragment">Bubble Sort</li><li class="fragment">Insertion Sort</li><li class="fragment">Quick Sort</li><li class="fragment">Merge Sort</li></ul></section></section><section><section><h2>Intro</h2></section><section><h2>Was ist Sortieren?</h2><p class="fragment">Neuordnung eines gegebenen Arrays oder einer Liste von Elementen nach einem Vergleichsoperator fÃ¼r die Elemente</p><p class="fragment">Alle Elemente werden entweder in aufsteigender oder in absteigender Reihenfolge neu angeordnet.</p></section><section><h2>Begriffe</h2><ul><li class="fragment" tabindex="0" data-tooltip="Ein In-place Sortieralgorithmus tauscht Elemente innerhalb der Liste aus.">In-place sorting</li><li class="fragment" tabindex="0" data-tooltip="Der komplette Input wird im lokalen Speicher gehalten. Der Input kann nicht grÃ¶ÃŸer sein als der lokale Speicher.">Internal Sorting</li><li class="fragment" tabindex="0" data-tooltip="Der komplette Input muss nicht im lokalen Speicher gehalten werden. Der Input kann grÃ¶ÃŸer sein als der lokale Speicher.">External Sorting</li><li class="fragment" tabindex="0" data-tooltip="Falls zwei Elemente &#x27;gleich&#x27; sind, wird die ursprÃ¼ngliche Reihenfolge beibehalten.">Stable Sorting</li><li class="fragment" tabindex="0" data-tooltip="Falls zwei Elemente &#x27;gleich&#x27; sind, wird die ursprÃ¼ngliche Reihenfolge nicht beibehalten.">Unstable Sorting</li></ul></section><section><h2>Stable und Unstable Sorting</h2><ul><li class="fragment">ğŸƒ… ğŸƒ• ğŸ‚² ğŸ‚ª â†’ Input</li><li class="fragment">ğŸ‚² ğŸƒ… ğŸƒ• ğŸ‚ª â†’ Stabil</li><li class="fragment">ğŸ‚² ğŸƒ• ğŸƒ… ğŸ‚ª â†’ Unstabil</li></ul><p class="foot-note fragment">Ein stabiler Sortieralgorithmus verÃ¤ndert nicht die ursprÃ¼ngliche Reihenfolge der 5er-Karten</p></section><section><h2>Anwendungen von Sortieralgorithmen</h2><ul><li tabindex="0" data-tooltip="BinÃ¤rsuche, Interpolationssuche etc.">Suchalgorithmen</li><li tabindex="0" data-tooltip="Abfragen, Indizes etc.">Datenbankoptimierung</li><li tabindex="0" data-tooltip="Muster, Trends etc.">Datenanalyse</li><li tabindex="0" data-tooltip="Scheduler, Arbeitsspeicherverwaltung etc.">Betriebssysteme</li></ul></section></section><section><section><h2>Selection Sort</h2></section><section><h2>Funktionsweise</h2><p>Beim Selection Sort wird wiederholt das kleinste Element aus dem unsortierten Teil der Liste ausgewÃ¤hlt und in den sortierten Teil der Liste verschoben.</p><p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</p></section><section><h2>Theoretisches Konzept</h2><ul><li class="fragment">Man setzt den Index auf Low</li><li class="fragment">Man durchsucht den restlichen Teil des Arrays nach dem kleinsten Element</li><li class="fragment">Man tauscht das kleinste Element mit dem Element am Index</li><li class="fragment">Index inkrementieren und wiederholen solange, bis alle Elemente sortiert sind.</li></ul></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/SelectionSort.java" target="_blank" rel="noopener noreferrer">Demo - Selection Sort</a></h2></section><section><h2>Performance</h2><ul><li class="fragment">ZeitkomplexitÃ¤t: O(NÂ²)</li><li class="fragment">SpeicherkomplexitÃ¤t: O(1)</li></ul></section><section><h2>Zusammenfassung</h2><ul><li class="fragment">Einfach zu implementieren</li><li class="fragment" data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸƒ” ğŸ‚´ ğŸ‚µ ğŸ‚¶  " tabindex="0">Nicht stabil</li></ul></section></section><section><section><h2>Bubble Sort</h2></section><section><h2>Funktionsweise</h2><p>Beim Bubble Sort wird wiederholt das grÃ¶ÃŸte Element aus dem unsortierten Teil der Liste in den sortierten Teil der Liste verschoben.</p><p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</p></section><section><h2>Theoretisches Konzept</h2><ul><li class="fragment">Man setzt den Index auf Low</li><li class="fragment">Man durchlÃ¤uft den unsortierten Teil des Arrays<!-- --> </li><li class="fragment">Ist das aktuelle Element am Index grÃ¶ÃŸer als das nÃ¤chste Element, werden Sie getauscht.</li><li class="fragment">High dekrementieren und wiederholen solange, bis alle Elemente sortiert sind.</li></ul></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/BubbleSort.java" target="_blank" rel="noopener noreferrer">Demo - Bubble Sort</a></h2></section><section><h2>Performance</h2><ul><li class="fragment">ZeitkomplexitÃ¤t: O(NÂ²)</li><li class="fragment">SpeicherkomplexitÃ¤t: O(1)</li></ul></section><section><h2>Zusammenfassung</h2><ul><li class="fragment">Einfach zu implementieren</li><li class="fragment" data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex="0">Stabil</li></ul></section></section><section><section><h2>Insertion Sort</h2></section><section><h2>Funktionsweise</h2><p>Beim Insertion Sort wird wiederholt das nÃ¤chste Element aus dem unsortierten Teil der Liste in die richtige Stelle des sortierten Teils der Liste verschoben.</p><p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</p></section><section><h2>Theoretisches Konzept</h2><ul><li class="fragment" data-tooltip="Das erste Element ist immer schon sortiert." tabindex="0">Man setzt den sortedHighIndex auf Low + 1</li><li class="fragment">Man durchlÃ¤uft den unsortierten Teil des Arrays</li><li class="fragment">Ist das aktuelle Element am Index kleiner als das vorherige Element, werden Sie getauscht.</li><li class="fragment">sortedHigh dekrementieren und wiederholen solange, bis Element an der richtigen Stelle sortiert ist</li></ul></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/InsertionSort.java" target="_blank" rel="noopener noreferrer">Demo - Insertion Sort</a></h2></section><section><h2>Performance</h2><ul><li class="fragment">ZeitkomplexitÃ¤t: O(NÂ²)</li><li class="fragment">SpeicherkomplexitÃ¤t: O(1)</li></ul></section><section><h2>Zusammenfassung</h2><ul><li class="fragment">Einfach zu implementieren</li><li class="fragment" data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex="0">Stabil</li></ul></section></section><section><section><h2>Quick Sort</h2></section><section><h2>Allgemein</h2><ul><li class="fragment">Divide and Conquer</li><li class="fragment">Rekursiv</li></ul></section><section><h2>Funktionsweise</h2><p class="fragment">Beim Quick Sort wird wiederholt der Input am freiwÃ¤hlbaren Pivotindex aufgeteilt. Jedes Element wird mit dem Pivotelement verglichen. Ist es kleiner als das Pivotelement wird es in den linken Teil verschoben, ansonsten in den rechten Teil.</p><p class="fragment">AnschlieÃŸend wird zuerst der linke Teil danach der rechte Teil sortiert.</p><p class="foot-note fragment">Beispiel: 10, 80, 30, 90, 40, 50, 70</p></section><section><h2>Theoretisches Konzept</h2><ul><li class="fragment">Base Case: Nur noch 1 Element Ã¼brig â†’ return;</li><li class="fragment">Pre Recurse: Aufteilen des Arrays in Links und Rechts</li><li class="fragment">Recurse: linke Seite anschlieÃŸend rechte Seite</li></ul></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/QuickSort.java" target="_blank" rel="noopener noreferrer">Demo - Quick Sort</a></h2></section><section><h2>Performance</h2><ul><li class="fragment">ZeitkomplexitÃ¤t: O(NÂ²)</li><li class="fragment">SpeicherkomplexitÃ¤t: O(1)</li></ul></section><section><h2>Zusammenfassung</h2><ul><li class="fragment" data-tooltip="Bei Best und Average Case, meistens zwischen Average und Worst Case" tabindex="0">Effizient bei groÃŸen Datenmengen O(N log N)</li><li class="fragment" data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex="0">Nicht stabil</li></ul></section></section><section><section><h2>Merge Sort</h2></section><section><h2>Allgemein</h2><ul><li class="fragment">Divide and Conquer</li><li class="fragment">Rekursiv</li></ul></section><section><h2>Funktionsweise</h2><p class="fragment">Beim Merge Sort wird wiederholt der Input in der Mitte aufgeteilt.</p><p class="fragment">AnschlieÃŸend wird zuerst der linke Teil danach der rechte Teil sortiert.</p><p class="fragment">AnschlieÃŸend werden der linke und der rechte Teil zusammengefÃ¼hrt.</p><p class="foot-note fragment">Beispiel: 69, 27, 11, 28, 2</p></section><section><h2>Theoretisches Konzept</h2><ul><li class="fragment">Base Case: Nur noch 1 Element Ã¼brig â†’ return;</li><li class="fragment">Pre Recurse: Aufteilen des Arrays in Links und Rechts</li><li class="fragment">Recurse: linke Seite anschlieÃŸend rechte Seite</li><li class="fragment">Post Recurse: linke Seite und rechte Seite zusammenfÃ¼hren</li></ul></section><section><h2><a href="https://github.com/jappuccini/java-exercises/tree/demos/steffen/demo/java2/dsa/sort/MergeSort.java" target="_blank" rel="noopener noreferrer">Demo - Merge Sort</a></h2></section><section><h2>Performance</h2><ul><li class="fragment">ZeitkomplexitÃ¤t: O(N log N)</li><li class="fragment">SpeicherkomplexitÃ¤t: O(N)</li></ul></section><section><h2>Zusammenfassung</h2><ul><li class="fragment" data-tooltip="Immer ğŸš€" tabindex="0">Effizient bei groÃŸen Datenmengen O(N log N)</li><li class="fragment" data-tooltip="Beispiel: ğŸ‚´ ğŸ‚µ ğŸ‚¶ ğŸƒ” ğŸ‚² â†’ ğŸ‚² ğŸ‚´ ğŸƒ” ğŸ‚µ ğŸ‚¶  " tabindex="0">Stabil</li><li class="fragment" data-tooltip="Es wird immer temporÃ¤r ein Kopie der Subarrays erstellt" tabindex="0">Speicherbedarf is Hoch</li><li class="fragment" data-tooltip="Es wird immer eine Kopie erstellt und anschlieÃŸend Ã¼berschrieben" tabindex="0">Kein In-Place Sort</li></ul></section></section><section><section><h2>Vergleich Sortieralgorithmen</h2></section><section><table><tr><th>Algorithmus</th><th>Best </th><th>Average </th><th>Worst </th></tr><tr class="fragment"><td>Selection Sort</td><td>O(NÂ²)</td><td>O(NÂ²)</td><td>O(NÂ²)</td></tr><tr class="fragment"><td>Bubble Sort</td><td>O(N)</td><td>O(NÂ²)</td><td>O(NÂ²)</td></tr><tr class="fragment"><td>Insertion Sort</td><td>O(N)</td><td>O(NÂ²)</td><td>O(NÂ²)</td></tr><tr class="fragment"><td>Quick Sort</td><td>O(N log N)</td><td>O(N log N)</td><td>O(NÂ²)</td></tr><tr class="fragment"><td>Merge Sort</td><td>O(N log N)</td><td>O(N log N)</td><td>O(N log N)</td></tr></table><p class="fragment foot-note">Merge Sort hat eine SpeicherkomplexitÃ¤t von O(N)</p></section></section><section><h2>Rest of the day</h2><ul><li class="fragment">Demo Code verstehen, debuggen, implementieren (Optional)</li><li class="fragment">Sort mit eigenem Problem (Optional)</li></ul></section></div></div></div>
</body>
</html>