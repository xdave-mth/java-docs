<!doctype html>
<html lang="de" dir="ltr" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.2.1">
<title data-rh="true">Programmieren mit Java</title><meta data-rh="true" property="og:title" content="Programmieren mit Java"><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://jappuccini.github.io/java-docs/slides/steffen/stream-api"><meta data-rh="true" property="og:locale" content="de"><meta data-rh="true" name="docusaurus_locale" content="de"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="de"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><link data-rh="true" rel="icon" href="/java-docs/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://jappuccini.github.io/java-docs/slides/steffen/stream-api"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/stream-api" hreflang="de"><link data-rh="true" rel="alternate" href="https://jappuccini.github.io/java-docs/slides/steffen/stream-api" hreflang="x-default"><link rel="stylesheet" href="/java-docs/assets/css/styles.482a3224.css">
<script src="/java-docs/assets/js/runtime~main.4deffe5b.js" defer="defer"></script>
<script src="/java-docs/assets/js/main.081cbc25.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div class="reveal reveal-viewport" style="width:100vw;height:100vh"><div class="slides"><section><section><h2>Agenda</h2><ul><li class="fragment">Intro Java Stream API</li><li class="fragment">Allgemeine Funktionale Interfaces</li><li class="fragment">Methodenreferenzen</li><li class="fragment">Java Stream API Aufbau</li><li class="fragment">Quellen</li><li class="fragment">Intermediate Operations</li><li class="fragment">Terminal Operations</li></ul></section></section><section><section><h2>Intro Java Stream API</h2></section><section><h2>Collection</h2><ul><li class="fragment">ArrayList&lt;Student&gt;</li><li class="fragment">ArrayList&lt;Car&gt;</li><li class="fragment">ArrayList&lt;Animal&gt;</li></ul><p class="fragment">Collections bieten einen direkten Zugriff auf die Elemente um Sie zu verwalten.</p></section><section><h2>Collection II</h2><ul><li>Daten abfragen → Name des ältesten Studenten</li><li>Daten ändern → Preis eines Produkts erhöhen</li></ul></section><section><h2>Was ist ein Java Stream?</h2><p class="fragment">Eine Sequenz (Abfolge) von Elementen, die funktionale Operationen (Funktionale Interfaces) unterstützt, um Daten zu verarbeiten, transformieren und aggregieren</p></section><section><h2>Streams vs Collection</h2><ul><li class="fragment">Streams können Daten nicht direkt bearbeiten</li><li class="fragment">Streams verarbeiten Daten verzögert (lazy)</li><li class="fragment">Streams verarbeiten Daten parallel</li></ul></section><section><h2>Demo</h2><ul><li class="fragment">Anzahl Studenten</li><li class="fragment">Älter als 24</li><li class="fragment">Vorname mindestens 4 Zeichen</li><li class="fragment">Fullname mehr als 10 Zeichen</li><li class="fragment">Jetzt mit Streams</li></ul></section></section><section><section><h2>Allgemeine Funktionale Interfaces</h2></section><section><h2>Grundkategorien von Funktionalen Interfaces</h2><ul><li class="fragment">Consumer</li><li class="fragment">Function</li><li class="fragment">Predicate</li><li class="fragment">Supplier</li></ul></section><section><h2>Consumer</h2><pre class="fragment"><code class="java">public interface Consumer&lt;T&gt; {
  public void accept(T t);
}
</code></pre><pre class="fragment"><code class="java">public interface BiConsumer&lt;T, U&gt; {
  public void accept(T t, U u);
}
</code></pre><p class="fragment">Code ausführen ohne Daten weiterzugeben.</p></section><section><h2>Function</h2><pre class="fragment"><code class="java">public interface Function&lt;T, R&gt; {
  public R apply(T t);
}
</code></pre><pre class="fragment"><code class="java">public interface BiFunction&lt;T, U, R&gt; {
  public R apply(T t, U u);
}
</code></pre><pre class="fragment"><code class="java">public interface UnaryOperator&lt;T&gt; {
  public T apply(T t);
}
</code></pre><pre class="fragment"><code class="java">public interface BinaryOperator&lt;T&gt; {
  public T apply(T t1, T t2);
}
</code></pre><p class="fragment">Code ausführen, der Daten zurückgibt.</p></section><section><h2>Predicate</h2><pre class="fragment"><code class="java">public interface Predicate&lt;T&gt; {
  public boolean test(T t);
}
</code></pre><p class="fragment">Code ausführen, der true oder false zurückgibt.</p></section><section><h2>Supplier</h2><pre class="fragment"><code class="java">public interface Supplier&lt;T&gt; {
  public T get();
}
</code></pre><p class="fragment">Code ausführen, der Daten vom Typ T zurückgibt.</p><p style="font-size:8px;position:absolute;bottom:0;right:0">*NKR</p></section><section><h2>Frag jetzt!</h2></section><section><h2>Demo Lambda Funktionen Auslagern</h2><ul><li class="fragment">Attribut: minimumFirstName</li><li class="fragment">Attribut: olderThan24Years</li><li class="fragment">Attribut: toFullName</li><li class="fragment">Methode: olderThanYears</li><li class="fragment">Methode: fullNameIsLongerThan</li></ul></section><section><h2>Frag jetzt!</h2></section></section><section><section><h2>Methodenreferenzen</h2></section><section><h2>Warum Methodenreferenzen?</h2><p class="fragment">Mit Methodenreferenzen kann man noch weniger Code schreiben.</p><p class="fragment">Hat ein Parameter die gleiche Signatur, wie eine Methode, kann diese Methode als Methodenreferenz übergeben werden.</p></section><section><h2>Beispiel ArrayList</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;()
    
    // lambda funktion
    names.forEach((name) -&gt System.out.println(name));
    
    // methodenreferenz
    names.forEach(System.out::println);
 }
}
</code></pre></section><section><h2>Verwenden von Methodenreferenzen?</h2><p class="fragment">Anstatt die Methode über einen Punkt aufzurufen, wird ein zweifacher Doppelpunkt verwendet.</p><p class="fragment">Mit dem &quot;new&quot; nach dem zweifachen Doppelpunkt kann auch der Konstruktor einer Klasse referenziert werden.</p><p style="font-size:8px;position:absolute;bottom:0;right:0">*NKR</p></section><section><h2>Demo Methodenreferenzen</h2><ul><li class="fragment">Methodensignatur Sysout</li><li class="fragment">OneTimePrinter</li></ul></section><section><h2>Frag jetzt!</h2></section><section><h2>Demo Composed Lambdas</h2><p style="font-size:8px;position:absolute;bottom:0;right:0">*NKR</p></section></section><section><section><h2>Java Stream API</h2></section><section><h2>Was is eine Stream Pipeline</h2><pre><code data-line-numbers="5-9|5|6-8|9" class="java">public class Main {
  public static void main(String[] args) {
    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;()
    
    names.stream() // source
      .filter(name -&gt; name.length > 4) //inter-
      .map(name -&gt; name.toUpperCase()) //mediate
      .limit(12)                      //operations
      .forEach(System.out::println) // terminal operation
  }
}
</code></pre></section><section><h4>Charakteristika einer Stream Pipeline</h4><ul><li class="fragment">Intermediate Operations sind optional</li><li class="fragment">Terminal Operation ist erforderlich</li><li class="fragment">Terminal Operation führt die Pipeline aus</li><li class="fragment">Pipeline kann nur einmal genutzt werden</li></ul></section><section><h2>Demo Stream API</h2><ul><li class="fragment">Intermediate Optional</li><li class="fragment">Terminal erforderlich, sonst passiert nichts</li><li class="fragment">Pipeline nur einmal Nutzbar</li><li class="fragment">Intermediate Reihenfolge</li></ul></section><section><h2>Aufbau einer Pipeline</h2><ul><li class="fragment">Quelle</li><li class="fragment">Intermediate Operations</li><li class="fragment">Terminal Operations</li></ul></section><section><h2>Frag jetzt!</h2></section></section><section><section><h2>Quellen</h2></section><section><h2>Erzeugen von Quellen I</h2><pre class="fragment"><code class="java">public class Main {
  public static void main(String[] args) {
    // Collection.stream(); // interface
    // &rarr; Klassen die Collection implementieren:
    ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();
    students.stream();
    
    HashMap&lt;String, Student&gt; map = new HashMap&lt;&gt;();
    map.keySet().stream();
    map.entrySet().stream();
    map.values().stream();
  }
}
</code></pre></section><section><h2>Erzeugen von Quellen II</h2><pre class="fragment"><code class="java">public class Main {
  public static void main(String[] args) {
    // Array in ein Stream konvertieren:
    // Arrays.stream(T[])
    Stream&lt;Integer&gt; num1 = Arrays.stream({ 1, 2, 3, 4 });
    
    int[] numArray = { 1, 2, 3, 4 };
    Stream&lt;Integer&gt; num2 = Arrays.stream(numArray);
  }
}
</code></pre></section><section><h2>Erzeugen von Quellen III</h2><pre class="fragment"><code class="java">public class Main {
  public static void main(String[] args) {
    // Gleichartige Werte in ein Stream kovertieren:
    // Stream.of(T...);
    Stream&lt;Integer&gt; num1 = Stream.of(1, 2, 3, 4);
  }
}
</code></pre></section><section><h2>Frag jetzt!</h2></section></section><section><section><h2>Intermediate Operations</h2></section><section><h2>Intermediate Operations</h2><p>sind Methoden eines Streams, die als Rückgabewert einen Stream zurückgeben.</p><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html" target="_blank" rel="noopener noreferrer">Stream Klasse</a></section><section><h2>filter - Methode</h2><pre class="fragment"><code class="java">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></pre><p class="fragment">Der Parameter predicate muss das<!-- --> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Predicate.html" target="_blank" rel="noopener noreferrer">Predicate Interface</a> <!-- -->implementieren.</p></section><section><h2>filter - Verwendung</h2><pre class="fragment"><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .filter(number -> number > 3);
      // nur 4 bleibt übrig
  }
}
</code></pre></section><section><h2>map - Methode</h2><pre class="fragment"><code class="java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code></pre><p class="fragment">Der Parameter mapper muss das<!-- --> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener noreferrer">Function Interface</a> <!-- -->implementieren.</p><p class="fragment">Die Eingabe vom Typ T definiert der vorherige Stream. Der Rückgabetyp des mapper Parameters definiert den Rückgabetyp des Streams.</p></section><section><h2>map - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .map(number -> number * 2);
    // Rückgabetyp: Stream&lt;Integer&gt;
    Stream.of(1, 2, 3, 4)
      .map(number -> String.valueOf(number));
    // Rückgabetyp: Stream&lt;String&gt;
  }
}
</code></pre></section><section><h2>limit - Methode</h2><pre class="fragment"><code class="java">Stream&lt;T&gt; limit(long maxSize)</code></pre><p class="fragment">Es werden maximal &quot;maxSize&quot; Elemente des vorherigen Streams weitergegeben.</p></section><section><h2>limit - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .limit(2);
      // nur 1 & 2 werden weitergegeben
  }
}
</code></pre></section><section><h2>skip - Methode</h2><pre class="fragment"><code class="java">Stream&lt;T&gt; skip(long n)</code></pre><p class="fragment">Es werden n-Elemente übersprungen.</p></section><section><h2>skip - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .skip(2);
      // nur 3 & 4 werden weitergegeben
  }
}
</code></pre></section><section><h2>sorted - Methode</h2><pre class="fragment"><code class="java">Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></pre><p class="fragment">Der Parameter comparator muss das<!-- --> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Comparator.html" target="_blank" rel="noopener noreferrer">Comparator Interface</a> <!-- -->implementieren.</p></section><section><h2>sorted - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(4, 3, 2, 1)
      .sorted((n1, n2) -> Integer.compare(n1, n2));
      // 1, 2, 3, 4
      // Sagt Bye Bye zu Collections.sort()
  }
}
</code></pre></section><section><h2>distinct - Methode</h2><pre class="fragment"><code class="java">Stream&lt;T&gt; distinct()</code></pre><p class="fragment">Es werden nur einzigartige Werte im Stream beibehalten. Diese werden Mithilfe von .equals identifiziert.</p></section><section><h2>distinct - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 1, 4)
      .distinct();
      // nur 1, 2 & 4 werden weitergegeben
  }
}
</code></pre></section><section><h2>Review von Stream Api Examples</h2><ul><li class="fragment">Student Example ohne Auslagerung</li><li class="fragment">Number Example Limit und Reihenfolge</li></ul></section><section><h2>Von Stream zu Stream</h2><p>Intermediate Operations werden auf einem Stream aufgerufen und geben immer einen Stream zurück.</p></section><section><h2>Frag jetzt!</h2></section></section><section><section><h2>Terminal Operations</h2></section><section><h2>Terminal Operations</h2><ul><li class="fragment">Matching und Suchen</li><li class="fragment">Transformationen</li><li class="fragment">Statistik</li><li class="fragment">Verarbeitung</li></ul></section><section><h2>Matching</h2><p>Mit Matching kann abgefragt werden ob bestimmte Elemente einer Bedingung entsprechen.</p></section><section><h2>Matching - Methoden</h2><pre><code class="java">boolean  allMatch(Predicate&lt;T&gt; predicate) // alle
boolean noneMatch(Predicate&lt;T&gt; predicate) // keiner
boolean  anyMatch(Predicate&lt;T&gt; predicate) // mindestens einer
</code></pre></section><section><h2>Matching - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .allMatch(number -> number > 3); // false
    
    Stream.of(1, 2, 3, 4)
      .noneMatch(number -> number > 4); // true
    
    Stream.of(1, 2, 3, 4)
      .anyMatch(number -> number > 2); // true
  }
}
</code></pre></section><section><h2>Suchen</h2><p>Mit findAny und findFirst wird das erste Element in einem Stream zurückgegeben.</p></section><section><h2>Suchen - Methoden</h2><pre><code class="java">Optional&lt;T&gt; findAny() // nicht deterministisch
Optional&lt;T&gt; findFirst() // deterministisch
</code></pre><p>Hauptsächlich wichtig bei parallelen Streams</p></section><section><h2>Suchen - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .filter(number -> number > 1)
      .findAny() // 2, 3 oder 4
    
    Stream.of(1, 2, 3, 4)
      .filter(number -> number > 1)
      .findFirst() // immer 2
  }
}
</code></pre></section><section><h2>Transformationen</h2><p>Die Ergebnismenge wird gesammelt.</p></section><section><h2>Transformationen - Methoden</h2><pre><code class="java">List&lt;T&gt; toList()
T[] toArray()

T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)

R collect(Collector&lt;T,A,R&gt; collector)
</code></pre></section><section><h2>Transformationen - Verwendung I </h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    List&lt;Integer&gt; nums = Stream.of(1, 2, 3, 4)
      .filter(number -> number > 1)
      .toList() // List&lt;Integer&gt;
    
    Object[] nums2 = Stream.of(1, 2, 3, 4)
      .filter(number -> number > 1)
      .toArray() // Object[]
  }
}
</code></pre></section><section><h2>Transformationen - Verwendung II </h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .reduce(0, (a, b) -> a + b);  // int *NKR
  }
}
</code></pre></section><section><h2>Transformationen - Verwendung III </h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    ArrayList&lt;Student&gt; students = getManyStudents()
      .stream()
      .collect(Collectors.toList());
      // Collectors.toMap ist Klausurrelevant
      // Collectors.groupingBy ist Klausurrelevant
  }
}
</code></pre></section><section><h2>Demo</h2><ul><li class="fragment"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html" target="_blank" rel="noopener noreferrer">Collectors Klasse</a></li><li class="fragment">Collectors.toMap</li><li class="fragment">Collectors.groupingBy</li></ul></section><section><h2>Statistik</h2><p>Mit Statistik Operationen lassen sich Anzahl, Minimum, Maximum, Summe und Durchschnitt berechnen.</p></section><section><h2>Statistik - Methoden</h2><pre><code class="java">long count()

Optional&lt;T&gt; min(Comparator&lt;T&gt;)
Optional&lt;T&gt; max(Comparator&lt;T&gt;)
</code></pre></section><section><h2>Statistik - Verwendung I</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .count(); // 4
  }
}
</code></pre></section><section><h2>Statistik - Verwendung II</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Optional&lt;Integer&gt; min = Stream.of(1, 2, 3, 4)
      .min((n1, n2) -> Integer.compare(n1, n2));
    
    min.ifPresent(System.out::println); // 1
  }
}
</code></pre></section><section><h2>Statistik - Verwendung III</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Optional&lt;Integer&gt; max = Stream.of(1, 2, 3, 4)
      .max((n1, n2) -> Integer.compare(n1, n2));
    
    max.ifPresent(System.out::println); // 4
  }
}
</code></pre></section><section><h2>Statistik Streams Erzeugen</h2><p>Für die Methoden Durchschnitt und Summe werden spezifische Streams benötigt:</p><ul><li class="fragment">IntStream</li><li class="fragment">LongStream</li><li class="fragment">DoubleStream</li></ul></section><section><h2>Statistik Streams Erzeugen - Methoden</h2><p>Um einen Statistik Stream zu erzeugen gibt es Intermediate Operations</p><pre><code class="java">DoubleStream mapToDouble(ToDoubleFunction&lt;T&gt; mapper)
IntStream    mapToInt(ToIntFunction&lt;T&gt; mapper)
LongStream   mapToLong(ToLongFunction&lt;T&gt; mapper)
</code></pre></section><section><h2>Statistik Streams Erzeugen - Verwenden</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    ArrayList&lt;Student&gt; students = getManyStudents();
    IntStream studentAges = students.stream()
      .mapToInt(student -> student.age());
  }
}
</code></pre></section><section><h2>Statistik Streams - Methoden</h2><pre><code class="java">long sum()
                           
OptionalDouble average()
</code></pre></section><section><h2>Statistik Streams - Verwendung I</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    IntStream manyNumbers = getManyNumbers();
    long sum = manyNumbers.sum();
  }
}
</code></pre></section><section><h2>Statistik - Verwendung II</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    IntStream manyNumbers = getManyNumbers();
    manyNumbers.average()
      .ifPresent(System.out::println);
  }
}
</code></pre></section><section><h2>Verarbeitung</h2><p>Mit forEach kann jedes einzelne Element nacheinander weiterverarbeitet werden.</p></section><section><h2>Verarbeitung - Methoden</h2><pre><code class="java">void forEach(Consumer&lt;T&gt; consumer)
</code></pre></section><section><h2>Verarbeitung - Verwendung</h2><pre><code class="java">public class Main {
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4)
      .filter(number -> number > 1)
      .forEach(System.out::println)
 
    Stream.of(1, 2, 3, 4)
      .filter(number -> number > 1)
      .forEach(n -> System.out.println(n));
  }
}
</code></pre></section></section><section><h2>Rest of the Day</h2><ul><li class="fragment">Lambda Aufgaben</li><li class="fragment">Stream API Aufgaben</li></ul></section></div></div></div>
</body>
</html>